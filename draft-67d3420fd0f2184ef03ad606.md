---
title: "Unit Testing Ktor Client Using MockEngine"
slug: unit-testing-ktor-client-using-mockengine
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1742070902087/99b15abf-58b1-40ae-ab2a-9ec4d5d6f2f3.webp
tags: kmp, kmm, mobile-development, kotlin, kotlin-multiplatform, hybrid-apps, software-development, software-engineering, testing, unit-testing, mock, mock-api-server

---

## Introduction

Unit testing has been a fundamental practice before product delivery in standard companies. Itâ€™s a crucial part of quality assurance process. If you are building a large scale software, tests are one way to improve reliability by catching bugs early. I personally consider software testing a less-talked-about topic in software engineering. When talking about testing, third party libraries and SDKs shouldnâ€™t be excluded.  
If you use a Ktor Client today for your network request, testing is essential to determine its working as expected. Writing test for Ktor client could also help increase comprehensive code coverage.  
In this article, we will explore the benefit of testing Ktor Client using mocks (like MockEngine).

**Bonus poin**tðŸ’¡: If you are like me, and you desire to reduce the back and forth between you, your PM and QA team, please read this article.

### MockEngine

MockEngine is a test dependency for Ktor, it let you replace real network calls with mocks by providing mock json responses and status codes. This engine can be used to test your concrete implementation directly. When testing Ktor client, its advisable to test your implementation against the expected responses and behavior from the backend side, I will explain more about this later.

### Setting up MockEngine

Assuming you already have Ktor setup in your project, to test using MockEngine, you need to add Ktor client mock dependency to your app level build gradle script.

```kotlin
//Kotlin DSL 
testImplementation("io.ktor:ktor-client-mock:$ktor_version")

//Groovy DSL
testImplementation "io.ktor:ktor-client-mock:$ktor_version"
```

If you havenâ€™t moved from Groovy DSL to Kotlin DSL, you have to do that soon, you are missing a lot ðŸ‘€

Lets create a simple API service class to play with. This API Service will have a `get` and `post` request that fetches user information and save user information respectively.

```kotlin
import io.ktor.client.HttpClient

data class User(
    userId: String,
    name: String,
    email: String,
)

interface MyApiService{
    suspended fun getUser(userId: String): User
    suspended fun saveUser(user: User): Unit
}

internal class KtorService(private val client: HttpClient): MyApiService{
    
    private val httpClient: HttpClient = HttpClient(client) {
        defaultRequest {
            contentType(ContentType.Application.Json)
            host = "https://api.example.com/"
        }
        install(ContentNegotiation) {
            json()
        }
    }

    override suspend fun getUser(userId: String,): User {
        return httpClient.get("user?userId=$userId")
    }

    override suspend fun saveUser(user: User): Unit {
        return httpClient.post("user/save-user",user)
    }
}
```

Now that we have an API services to work with, lets itemize possible test scenarios for this Service.

### Scenario #1: Ensuring Requests Hit the Correct Endpoint

There is no built-in way to determine requests sent are hitting the right endpoint without manual testing. we can utilize MockEngine to verify that requests are sent to the expected URL.

### Scenario #2: Validating Json Mapping to Data Models

JSON-to-Kotlin deserialization can fail due to incorrect field names, missing fields, or type mismatch.  
There are no definite way to determine that our `User` model is a valid representation of the expected JSON response without manual testing. We can use MockEngine here to determine if our model maps to a valid JSON string using MockEngine.

### Scenario #3 Handling API Errors Correctly.

We have no way to know if our error management is on point unless we test this manually, what happens when the server returns 4XX or may be 5XX are there proper strategies in place to handles this errors? we can use MockEngine to ascertain this.

### Scenario #4 Ensuring Correct HTTP method Usage

A `POST` request could be mistakenly implemented as a `GET` request, leading to unexpected behavior, there is no way to determine this except by performing a manual testing. We can use MockEngine to inspect request methods and verify that the right method was used.

There are far many scenario we can test from this Ktor Service, but we will be working with the above scenario.

### Testing Scenarios

First, we start by creating a reusable function for setting up MockEngine. We can call this function with our desired configuration for each test scenario.

```kotlin
internal class KtorServiceTest {
    //mockEngine
    fun setUpMockEngine( 
        responseBody: String,
        responseCode: HttpStatusCode = HttpStatusCode.OK,
    ): HttpClient {
        val mockEngine = MockEngine {
            respond(
                content = ByteReadChannel(responseBody),
                headers = headersOf(HttpHeaders.ContentType, "application/json"),
                status = responseCode,
            )
        }
        return HttpClient(mockEngine) {
            defaultRequest {
                contentType(ContentType.Application.Json)
            }
            install(ContentNegotiation) { json(json = Json { ignoreUnknownKeys = true }) }
       }
    }
}
```

### Testing Scenario #1 Ensuring Requests Hit the Correct Endpoint

Before we begin testing this scenario, I want to highlight a useful IntelliJ IDEA feature for handling JSON strings. When testing with MockEngine, you often need to provide a mock JSON response to simulate the expected response from the endpoint. Representing a JSON string as a regular string can be challenging because you might accidentally omit a comma or curly brace, which could break the JSON structure. By using Kotlin's raw string literals along with a comment specifying the language type, you can take advantage of IntelliJ's syntax highlighting. This feature enhances the readability and accuracy of your JSON strings. Here's a quick example:

```kotlin
val someJsonResponse = 
//language=json
"""
{
    "name": "Mubarack Tahir"
}       
"""
```

This feature isn't limited to JSON; it also supports different languages, including HTML and JavaScript. Now, let's return to testing the first scenario. Below is a code snippet that demonstrates how to verify that requests are sent to the correct endpoint.

```kotlin
import kotlin.test.Test
import kotlin.test.assertEquals

internal class KtorServiceTest {
    ....

    @Test
    fun `request should be sent to the correct endpoint`(){
        val client = setUpMockEngine(
            reponseBody = 
            //language=JSON
            """
            {
                "status": "SUCCESS"
            }
            """
        val service = KtorService(service = client)
        val request = client.engine.requestHistory.first()

        assertEquals("/user/save-user", request.url.encodedPath)
    }
}
```

### Testing Scenario #2 Validating Json Mapping to Data Models.

```kotlin
import kotlin.test.Test
import kotlin.test.assertEquals

internal class KtorServiceTest {
    ....

    @Test
    fun `model should map to correct json`(){
        val client = setUpMockEngine(
            reponseBody = 
            //language=JSON
            """
            {
                "status": "SUCCESS"
            }
            """
        val service = KtorService(service = client)

        with(engine.requestHistory.first()) {
            assertEquals("/user?userId=0", url.encodedPath)
            assertEquals(
                //language=JSON
                """
                    {
                       "userId": 0,
                       "name": "Mubarack Tahir",
                       "email": "test@mailinator.com"
                    }
                """.removeWhiteSpaces(),
                body.toByteArray().decodeToString()
            )
        }
    }
}
```

When verifying if a model maps to the expected JSON, it's advisable to test the model against the expected response from the backend service. This information can be obtained from your API documentation, such as those on Postman or Spotlight. Doing so helps ensure that the contracts with the backend are adhered to.

### Testing Scenario #3 Handling API Errors Correctly.